<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>一只博客</title><link>https://fluent12138.github.io/</link><description>用树木去接近星辰是大地的梦想。</description><copyright>一只博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.acwing.com/media/article/image/2023/05/28/36510_044ec922fc-3.png</url><title>avatar</title><link>https://fluent12138.github.io/</link></image><lastBuildDate>Sun, 10 Mar 2024 08:30:01 +0000</lastBuildDate><managingEditor>一只博客</managingEditor><ttl>60</ttl><webMaster>一只博客</webMaster><item><title>7天用Go从零实现Web框架Gee</title><link>https://fluent12138.github.io//post/7-tian-yong-Go-cong-ling-shi-xian-Web-kuang-jia-Gee.html</link><description>## 准备阶段&#13;
- 环境搭建, 搭了两份&#13;
    - 使用wsl2 ubuntu镜像, 直接命令行安装, 嘎嘎快&#13;
    - windows本机安装go,  [参考链接](https://blog.csdn.net/qq_34902437/article/details/120699775) &#13;
- ide&#13;
    - 熟悉语法阶段: `vim` (y总配置嘎嘎好用)&#13;
    - 正式编写阶段: `idea 2021`&#13;
- 版本控制: `git`&#13;
&#13;
## day1&#13;
- 代码量: `50行`&#13;
- 主要内容&#13;
    - 了解go中http模块的作用&#13;
    - 自定义路由 + 回调方法&#13;
    - 框架结构定义&#13;
&#13;
**框架基本结构**&#13;
```go&#13;
// 文件结构&#13;
.&#13;
├── base1&#13;
│   └── main.go&#13;
├── base2&#13;
│   └── main.go&#13;
└── base3&#13;
    ├── fgee&#13;
    │   ├── fgee.go&#13;
    │   └── go.mod&#13;
    ├── go.mod&#13;
    └── main.go&#13;
&#13;
// 只有一个路由对应的map&#13;
// 比如定义了一个路由为 "/hello", 回调方法为helloFunc, 就会存在这个结构体中 {"/hello" : helloFunc}&#13;
// 当请求了这个路径, 通过路径找到对应方法, 然后执行&#13;
&#13;
type Engine struct {&#13;
	router map[string]HandlerFunc&#13;
}&#13;
```&#13;
&#13;
## day2&#13;
&#13;
- 总代码量:约`140行`, 新增`90行`&#13;
- 主要内容&#13;
    - 封装数据&#13;
        - 定义上下文封装请求过程需要的数据&#13;
        - 封装路由为单独一个模块, `router.go`&#13;
    - 定义通用方法: 例如响应HTML页面, 响应字符串, 响应json数据&#13;
&#13;
**框架基本结构**&#13;
&#13;
```go&#13;
// 文件结构&#13;
.&#13;
├── fgee&#13;
│   ├── context.go&#13;
│   ├── fgee.go&#13;
│   ├── go.mod&#13;
│   └── router.go&#13;
├── go.mod&#13;
└── main.go&#13;
&#13;
// fgee.go文件&#13;
&#13;
type Engine struct {&#13;
	router *router // 由之前的map封装为结构体&#13;
}&#13;
&#13;
// context.go文件&#13;
// Context 上下文结构&#13;
// 在ServeHTTP方法中被创建&#13;
&#13;
type Context struct {&#13;
	// 请求与响应&#13;
	Req    *http.Request&#13;
	Writer http.ResponseWriter&#13;
	// 请求信息&#13;
	Path   string&#13;
	Method string&#13;
	// 响应信息&#13;
	StatusCode int&#13;
}&#13;
&#13;
// 每次请求都会创建一个单独的context, 为这个请求服务&#13;
```&#13;
&#13;
## day3&#13;
&#13;
- 总代码量: 约`290行` 新增代码: 约`150行`&#13;
- 主要内容&#13;
    - 添加动态路由, 使用`字典树`&#13;
    - 支持 `:name`与`*filepath`两种模式&#13;
- 有点忘了字典树是啥了, 写之前还回顾了一下基础课字典树 : )&#13;
&#13;
 **字典树操作** &#13;
 &#13;
- 插入: 对应创建路由时, 把路由插入字典树中&#13;
- 查询: 当请求来临时, 去字典树找到对应的路由&#13;
&#13;
**框架基本结构**&#13;
```go&#13;
// 文件结构&#13;
.&#13;
├── fgee&#13;
│   ├── context.go&#13;
│   ├── fgee.go&#13;
│   ├── go.mod&#13;
│   ├── router.go&#13;
│   ├── router_test.go&#13;
│   └── tire.go&#13;
├── go.mod&#13;
└── main.go&#13;
&#13;
// context.go&#13;
&#13;
// Context 上下文结构&#13;
// 在ServeHTTP方法中被创建&#13;
type Context struct {&#13;
	// 请求与响应&#13;
	Req    *http.Request&#13;
	Writer http.ResponseWriter&#13;
	// 请求信息&#13;
	Path   string&#13;
	Method string&#13;
	// 路由匹配后的参数&#13;
	Params map[string]string&#13;
	// 响应信息&#13;
	StatusCode int&#13;
}&#13;
```&#13;
- 存在问题: 字典树处理不严谨, 路由会冲突, 比如创建路由/:age, 再创建路由/16, 这样就会出现冲突问题&#13;
&#13;
&#13;
**教程链接**&#13;
&#13;
&gt; [7天用Go从零实现Web框架Gee教程](https://geektutu.com/post/gee.html)。</description><guid isPermaLink="true">https://fluent12138.github.io//post/7-tian-yong-Go-cong-ling-shi-xian-Web-kuang-jia-Gee.html</guid><pubDate>Sun, 10 Mar 2024 08:22:06 +0000</pubDate></item><item><title>erlang-gen_fsm 游戏交易</title><link>https://fluent12138.github.io//post/erlang-gen_fsm%20-you-xi-jiao-yi.html</link><description>![fsm-游戏交易.excalidraw.png](https://cdn.acwing.com/media/article/image/2023/04/04/36510_86007705d2-fsm-游戏交易.excalidraw.png)&#13;
&#13;
 **code** &#13;
 &#13;
```&#13;
%%%-------------------------------------------------------------------&#13;
%%% @author 勒勒&#13;
%%% @copyright (C) 2023, &lt;COMPANY&gt;&#13;
%%% @doc&#13;
%%%&#13;
%%% @end&#13;
%%% Created : 31. 3月 2023 14:38&#13;
%%%-------------------------------------------------------------------&#13;
-module(trade_fsm).&#13;
-author("勒勒").&#13;
-behavior(gen_fsm).&#13;
-record(state, {name = "", other, ownitems = [], otheritems = [], monitor, from}). % from就是gen_fsm中发送消息处&#13;
%% 公共API&#13;
-export([start/1, start_link/1, trade/2, accept_trade/1, make_offer/2, retract_offer/2, ready/1, cancel/1]).&#13;
%% gen_sfm回调函数&#13;
-export([init/1, handle_event/3, handle_sync_event/4, handle_info/3, terminate/3, code_change/4,&#13;
        % 定制的状态名&#13;
        idle/2, idle/3, idle_wait/2, idle_wait/3, negotiate/2, negotiate/3, wait/2, ready/2, ready/3&#13;
        ]).&#13;
&#13;
%%% 公共API&#13;
start(Name) -&gt; gen_fsm:start(?MODULE, [Name], []).&#13;
&#13;
start_link(Name) -&gt; gen_fsm:start_link(?MODULE, [Name], []).&#13;
&#13;
%% 请求开始交易谈话. 当/如果对方接收时返回&#13;
trade(OwnPid, OtherPid) -&gt;&#13;
  gen_fsm:sync_send_event(OwnPid, {negotiate, OtherPid}, 30000).&#13;
&#13;
%% 接收某个玩家的交易请求&#13;
accept_trade(OwnPid) -&gt;&#13;
  gen_fsm:sync_send_event(OwnPid, accept_negotiate).&#13;
&#13;
%% 从物品列表中选择一个进行交易&#13;
make_offer(OwnPid, Item) -&gt;&#13;
  gen_fsm:send_event(OwnPid, {make_offer, Item}).&#13;
&#13;
%% 撤销某个交易物品&#13;
retract_offer(OwnPid, Item) -&gt;&#13;
  gen_fsm:send_event(OwnPid, {retract_offer, Item}).&#13;
&#13;
%% 宣布自己就绪. 当对方也宣布自己就绪了, 交易就完成了.&#13;
ready(OwnPid) -&gt;&#13;
  gen_fsm:sync_send_event(OwnPid, ready, infinity).&#13;
&#13;
%% 取消交易&#13;
cancel(OwnPid) -&gt;&#13;
  gen_fsm:sync_send_all_state_event(OwnPid, cancel).&#13;
&#13;
%%% FSM 到 FSM&#13;
&#13;
%% 向另一个FSM发送交易会话请求&#13;
ask_negotiate(OwnPid, OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {ask_negotiate, OwnPid}).&#13;
&#13;
%% 转发玩家交易接收请求&#13;
accept_negotiate(OtherPid, OwnPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {accept_negotiate, OwnPid}).&#13;
&#13;
%% 转发玩家的交易物品提供信息&#13;
do_offer(OtherPid, Item) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {do_offer, Item}).&#13;
&#13;
%% 转发玩家交易物品撤销请求&#13;
undo_offer(OtherPid, Item) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {undo_offer, Item}).&#13;
&#13;
%% 询问对方是否就绪&#13;
are_you_ready(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, are_you_ready).&#13;
&#13;
%% 回复未就绪 -&gt; 不在wait状态哦&#13;
not_yet(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, not_yet).&#13;
&#13;
%% 通知对方玩家当前处于等待进入ready状态&#13;
%% 状态会迁移到ready ?&#13;
am_ready(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, 'ready!').&#13;
&#13;
%% 确认fsm处于ready状态&#13;
ack_trans(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, ack).&#13;
&#13;
%% 询问是否可以提交&#13;
ask_commit(OtherPid) -&gt;&#13;
  gen_fsm:sync_send_event(OtherPid, ask_commit).&#13;
&#13;
%% 开始同步提交&#13;
do_commit(OtherPid) -&gt;&#13;
  gen_fsm:sync_send_event(OtherPid, do_commit).&#13;
&#13;
%% 礼貌取消&#13;
notify_cancel(OtherPid) -&gt;&#13;
  gen_fsm:send_all_state_event(OtherPid, cancel).&#13;
&#13;
init(Name) -&gt;&#13;
  {ok, idle, #state{name = Name}}.&#13;
&#13;
%% 给玩家发送一条通知, 可以是一条发给玩家进程的消息&#13;
%% 打印在控制台就ok了&#13;
notice(#state{name = N}, Str, Args) -&gt;&#13;
  io:format("~s : "++ Str ++ "~n", [N | Args]).&#13;
&#13;
%% 记录非期望的消息&#13;
unexpected(Msg, State) -&gt;&#13;
  io:format("~p receive unknown event ~p while in state ~p", [self(), Msg, State]).&#13;
&#13;
%%% idle 请求/接收 交易&#13;
%% 异步版本, 关心其他玩家的交易请求&#13;
idle({ask_negotiate, OtherPid}, S = #state{}) -&gt;&#13;
  Ref = monitor(process, OtherPid),&#13;
  notice(S, "~p asked for a trade negotiation", [OtherPid]),&#13;
  {next_state, idle_wait, S#state{other = OtherPid, monitor = Ref}};&#13;
&#13;
idle(Event, Data) -&gt;&#13;
  unexpected(Event, idle),&#13;
  {next_state, idle, Data}.&#13;
&#13;
%% 同步版本, 本方玩家请求另一个玩家进行交易&#13;
idle({negotiate, OtherPid}, From, S=#state{}) -&gt;&#13;
  ask_negotiate(OtherPid, self()),&#13;
  notice(S, "asking user ~p for a trade", [OtherPid]),&#13;
  Ref = monitor(process, OtherPid),&#13;
  {next_state, idle_wait, S = #state{other = OtherPid, monitor = Ref, from = From}};&#13;
&#13;
idle(Event, _From, Data) -&gt;&#13;
  unexpected(Event, idle),&#13;
  {next_state, idle, Data}.&#13;
&#13;
%%% idle_wait&#13;
%% 接收方, 1.同意协商 2.在我们发送交易请求时, 他也发起了交易&#13;
idle_wait({ask_negotiate, OtherPid}, S = #state{other = OtherPid}) -&gt;&#13;
  gen_fsm:reply(S#state.from, ok), % 通知玩家一切正常&#13;
  notice(S, "starting negotiation", []),&#13;
  {next_state, negotiate, S};&#13;
&#13;
%% 对方接受了我们的请求, 迁移negotiate状态&#13;
idle_wait({accept_negotiate, OtherPid}, S = #state{other = OtherPid}) -&gt;&#13;
  gen_fsm:reply(S#state.from, ok), % 通知玩家一切正常&#13;
  notice(S, "starting negotiation", []),&#13;
  {next_state, negotiate, S};&#13;
&#13;
idle_wait(Event, Data) -&gt;&#13;
  unexpected(Event, idle_wait),&#13;
  {next_state, idle_wait, Data}.&#13;
&#13;
%% 发送方, 接收对方玩家请求&#13;
idle_wait(accept_negotiate, _From, S = #state{other = OtherPid}) -&gt;&#13;
  accept_negotiate(OtherPid, self()),&#13;
  notice(S, "accepting negotiation", []),&#13;
  {reply, ok, negotiate, S};&#13;
&#13;
idle_wait(Event, _From, Data) -&gt;&#13;
  unexpected(Event, idle_wait),&#13;
  {next_state, idle_wait, Data}.&#13;
&#13;
%% 向物品列表中添加一个物品&#13;
add(Item, Items) -&gt;&#13;
  [Item|Items].&#13;
&#13;
%% 从物品列表中删除一个物品&#13;
remove(Item, Items) -&gt;&#13;
  Items -- [Item].&#13;
&#13;
%%% negotiate&#13;
%% 本方提供物品&#13;
negotiate({make_offer, Item}, S = #state{ownitems = OwnItems}) -&gt;&#13;
  do_offer(S#state.other, Item),&#13;
  notice(S, "offering ~p", [Item]),&#13;
  {next_state, negotiate, S#state{ownitems = add(Item, OwnItems)}};&#13;
&#13;
%% 本方撤销物品&#13;
negotiate({retract_offer, Item}, S = #state{ownitems = OwnItems}) -&gt;&#13;
  undo_offer(S#state.other, Item),&#13;
  notice(S, "cancelling offer on ~p", [Item]),&#13;
  {next_state, negotiate, S#state{ownitems = remove(Item, OwnItems)}};&#13;
&#13;
%% 对方提供物品&#13;
negotiate({do_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  notice(S, "other player offering ~p", [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = add(Item, OtherItems)}};&#13;
&#13;
%% 对方撤销物品&#13;
negotiate({undo_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  notice(S, "other player cancelling offer on ~p", [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = OtherItems}};&#13;
&#13;
%% 当在negotiate状态时, 接收到对方的ready信号, 直接拒绝.&#13;
negotiate(are_you_ready, S = #state{other = OtherPid}) -&gt;&#13;
  io:format("Other user ready to trade ~n"),&#13;
  notice(S, "Other user ready to transfer goods : ~n You get ~p, The Other side gets ~p", [S#state.otheritems, S#state.ownitems]),&#13;
  not_yet(OtherPid),&#13;
  {next_state, negotiate, S};&#13;
&#13;
negotiate(Event, Data) -&gt;&#13;
  unexpected(Event, negotiate),&#13;
  {next_state, negotiate, Data}.&#13;
&#13;
%% 玩家做完决策 -&gt; 发送ready&#13;
negotiate(ready, From, S = #state{other = OtherPid}) -&gt;&#13;
  are_you_ready(OtherPid),&#13;
  notice(S, "asking if ready, waiting", []),&#13;
  {next_state, wait, S = #state{from = From}};&#13;
&#13;
negotiate(Event, _From, S) -&gt;&#13;
  unexpected(Event, negotiate),&#13;
  {next_state, negotiate, S}.&#13;
&#13;
%%% wait&#13;
&#13;
%% 当对方撤销/提供物品了, 回退到negotiate状态&#13;
wait({do_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  gen_fsm:reply(S#state.from, offer_changed), % 通知negotiate状态&#13;
  notice(S, "other side offering ~p", [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = add(Item, OtherItems)}};&#13;
&#13;
wait({undo_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  gen_fsm:reply(S#state.from, offer_changed), % 通知negotiate状态&#13;
  notice(S, "other side cancelling offer of ~p", [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = remove(Item, OtherItems)}};&#13;
&#13;
%% 对方询问本方是否ready&#13;
wait(are_you_ready, S = #state{}) -&gt;&#13;
  am_ready(S#state.other),&#13;
  notice(S, "asked if ready, and I am. Waiting for same reply", []),&#13;
  {next_state, wait, S};&#13;
&#13;
%% 对方不同意&#13;
wait(not_yet, S = #state{}) -&gt;&#13;
  notice(S, "Other not ready yet", []),&#13;
  {next_state, wait, S};&#13;
&#13;
%% 收到ready!&#13;
wait('ready!', S = #state{}) -&gt;&#13;
  am_ready(S#state.other),&#13;
  ack_trans(S#state.other),&#13;
  gen_fsm:reply(#state.from, ok),&#13;
  notice(S, "other side is ready. Moving to ready state", []),&#13;
  {next_state, ready, S};&#13;
&#13;
%% 不期待的消息&#13;
wait(Event, Data) -&gt;&#13;
  unexpected(Event, wait),&#13;
  {next_state, wait, Data}.&#13;
&#13;
%%% ready, 选择一个FSM去完成ready, erlang中进程是排好序的, 可以比较大小&#13;
priority(OwnPid, OtherPid) when OwnPid &gt; OtherPid -&gt; true;&#13;
priority(OwnPid, OtherPid) when OtherPid &gt; OwnPid -&gt; false.&#13;
&#13;
ready(ack, S = #state{}) -&gt;&#13;
  case priority(self(), S#state.other) of&#13;
      true -&gt;&#13;
        try&#13;
          notice(S, "asking for commit", []),&#13;
          ready_commit = ask_commit(S#state.other),&#13;
          notice(S, "ordering commit", []),&#13;
          ok = do_commit(S#state.other),&#13;
          commit(S),&#13;
          {stop, normal, S}&#13;
        catch Class:Reason -&gt;&#13;
          %% 退出!, ready_commit或do_commit失败了&#13;
          notice(S, "commit failed", []),&#13;
          {stop, {Class, Reason}, S}&#13;
        end;&#13;
      false -&gt;&#13;
        {next_state, ready, S}&#13;
  end;&#13;
&#13;
ready(Event, Data) -&gt;&#13;
  unexpected(Event, ready),&#13;
  {next_state, ready, Data}.&#13;
&#13;
ready(ask_commit, _From, S) -&gt;&#13;
  notice(S, "replying to ask_commit", []),&#13;
  {reply, ready_commit, ready, S};&#13;
&#13;
ready(do_commit, _From, S) -&gt;&#13;
  notice(S, "commiting...", []),&#13;
  commit(S),&#13;
  {stop, normal, ok, S};&#13;
&#13;
ready(Event, _From, S) -&gt;&#13;
  unexpected(Event, ready),&#13;
  {next_state, ready, S}.&#13;
&#13;
commit(S = #state{}) -&gt;&#13;
  io:format("Transaction completed for ~s.", [S#state.name]),&#13;
  io:format("Items send are: ~n ~p ~n received are: ~n ~p ~n", [S#state.ownitems, S#state.otheritems]),&#13;
  io:format("The operation should have some atomic save in a database").&#13;
&#13;
%% 对方玩家取消交易&#13;
%% 停止正再做的工作 终止进程&#13;
handle_event(cancel, _StateName, S = #state{}) -&gt;&#13;
  notice(S, "received cancel event", []),&#13;
  {stop, other_cancelled, S};&#13;
&#13;
handle_event(Event, StateName, Data) -&gt;&#13;
  unexpected(Event, StateName),&#13;
  {next_state, StateName, Data}.&#13;
&#13;
%% 本方玩家终止交易, 必须通知对方玩家我们退出了&#13;
handle_sync_event(cancel, _From, _StateName, S = #state{}) -&gt;&#13;
  notify_cancel(S#state.other),&#13;
  notice(S, "cancelling trade, sending cancel event", []),&#13;
  {stop, cancelled, ok, S};&#13;
&#13;
handle_sync_event(Event, _From, StateName, Data) -&gt;&#13;
  unexpected(Event, StateName),&#13;
  {next_state, StateName, Data}.&#13;
&#13;
%% 处理对方FSM崩溃事件&#13;
handle_info({'DOWN', Ref, process, Pid, Reason}, _, S = #state{other = Pid, monitor=Ref}) -&gt;&#13;
  notice(S, "Other side dead", []),&#13;
  {stop, {other_down, Reason}, S};&#13;
&#13;
handle_info(Info, StateName, Data) -&gt;&#13;
  unexpected(Info, StateName),&#13;
  {next_state, StateName, Data}.&#13;
&#13;
code_change(_OldVsn, StateName, Data, _Extra) -&gt;&#13;
  {ok, StateName, Data}.&#13;
&#13;
terminate(_Reason, _StateName, _StateData) -&gt; ok.&#13;
```&#13;
&lt;!-- ##{"timestamp":1680616800}## --&gt;。</description><guid isPermaLink="true">https://fluent12138.github.io//post/erlang-gen_fsm%20-you-xi-jiao-yi.html</guid><pubDate>Tue, 04 Apr 2023 14:00:00 +0000</pubDate></item><item><title>关于</title><link>https://fluent12138.github.io//about.html</link><description>## 一个正在努力生活的人&#13;
&#13;
- 正在用的吃饭的家伙&#13;
    - Erlang&#13;
- 以后可能会让我吃上饭的家伙&#13;
    - Go、Java&#13;
    &#13;
**希望大家都能好好吃饭！**。</description><guid isPermaLink="true">https://fluent12138.github.io//about.html</guid><pubDate>Sun, 10 Mar 2024 08:18:58 +0000</pubDate></item></channel></rss>