<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>一只博客</title><link>https://fluent12138.github.io/</link><description>用树木去接近星辰是大地的梦想。</description><copyright>一只博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://cdn.acwing.com/media/article/image/2023/05/28/36510_044ec922fc-3.png</url><title>avatar</title><link>https://fluent12138.github.io/</link></image><lastBuildDate>Mon, 20 May 2024 16:23:19 +0000</lastBuildDate><managingEditor>一只博客</managingEditor><ttl>60</ttl><webMaster>一只博客</webMaster><item><title>多语言环境搭建</title><link>https://fluent12138.github.io//post/duo-yu-yan-huan-jing-da-jian.html</link><description># 多语言环境搭建&#13;
&#13;
&gt; &#13;
为了方便多语言环境搭建编写的脚本 : )&#13;
&#13;
[GitHub](https://github.com/fluent12138/mutil_lang_env)  &#13;
&#13;
&#13;
### 目录结构&#13;
&#13;
```&#13;
.&#13;
|-- README.md&#13;
|-- docker-compose.yaml&#13;
|-- gen_yaml.py&#13;
```&#13;
&#13;
### 使用说明&#13;
&#13;
1. 确保您的系统中已安装 Docker 和 Docker Compose。</description><guid isPermaLink="true">https://fluent12138.github.io//post/duo-yu-yan-huan-jing-da-jian.html</guid><pubDate>Sun, 19 May 2024 04:31:45 +0000</pubDate></item><item><title>主题月</title><link>https://fluent12138.github.io//post/zhu-ti-yue.html</link><description>## 起因&#13;
&#13;
&gt; 24年2月某天从B站上看到[这个视频](https://www.bilibili.com/video/BV1zz421X7KD/?spm_id_from=333.337.search-card.all.click)后觉得很有意思， 然后就列了一些主题开始做了起来。</description><guid isPermaLink="true">https://fluent12138.github.io//post/zhu-ti-yue.html</guid><pubDate>Sun, 10 Mar 2024 09:47:32 +0000</pubDate></item><item><title>7天用Go从零实现Web框架Gee</title><link>https://fluent12138.github.io//post/7-tian-yong-Go-cong-ling-shi-xian-Web-kuang-jia-Gee.html</link><description>## 准备阶段&#13;
- 环境搭建, 搭了两份&#13;
    - 使用wsl2 ubuntu镜像, 直接命令行安装, 嘎嘎快&#13;
    - windows本机安装go,  [参考链接](https://blog.csdn.net/qq_34902437/article/details/120699775) &#13;
- ide&#13;
    - 熟悉语法阶段: `vim` (y总配置嘎嘎好用)&#13;
    - 正式编写阶段: `idea 2021`&#13;
- 版本控制: `git`&#13;
&#13;
## day1&#13;
- 代码量: `50行`&#13;
- 主要内容&#13;
    - 了解go中http模块的作用&#13;
    - 自定义路由 + 回调方法&#13;
    - 框架结构定义&#13;
&#13;
**框架基本结构**&#13;
```go&#13;
// 文件结构&#13;
.&#13;
├── base1&#13;
│   └── main.go&#13;
├── base2&#13;
│   └── main.go&#13;
└── base3&#13;
    ├── fgee&#13;
    │   ├── fgee.go&#13;
    │   └── go.mod&#13;
    ├── go.mod&#13;
    └── main.go&#13;
&#13;
// 只有一个路由对应的map&#13;
// 比如定义了一个路由为 '/hello', 回调方法为helloFunc, 就会存在这个结构体中 {'/hello' : helloFunc}&#13;
// 当请求了这个路径, 通过路径找到对应方法, 然后执行&#13;
&#13;
type Engine struct {&#13;
	router map[string]HandlerFunc&#13;
}&#13;
```&#13;
&#13;
## day2&#13;
&#13;
- 总代码量:约`140行`, 新增`90行`&#13;
- 主要内容&#13;
    - 封装数据&#13;
        - 定义上下文封装请求过程需要的数据&#13;
        - 封装路由为单独一个模块, `router.go`&#13;
    - 定义通用方法: 例如响应HTML页面, 响应字符串, 响应json数据&#13;
&#13;
**框架基本结构**&#13;
&#13;
```go&#13;
// 文件结构&#13;
.&#13;
├── fgee&#13;
│   ├── context.go&#13;
│   ├── fgee.go&#13;
│   ├── go.mod&#13;
│   └── router.go&#13;
├── go.mod&#13;
└── main.go&#13;
&#13;
// fgee.go文件&#13;
&#13;
type Engine struct {&#13;
	router *router // 由之前的map封装为结构体&#13;
}&#13;
&#13;
// context.go文件&#13;
// Context 上下文结构&#13;
// 在ServeHTTP方法中被创建&#13;
&#13;
type Context struct {&#13;
	// 请求与响应&#13;
	Req    *http.Request&#13;
	Writer http.ResponseWriter&#13;
	// 请求信息&#13;
	Path   string&#13;
	Method string&#13;
	// 响应信息&#13;
	StatusCode int&#13;
}&#13;
&#13;
// 每次请求都会创建一个单独的context, 为这个请求服务&#13;
```&#13;
&#13;
## day3&#13;
&#13;
- 总代码量: 约`290行` 新增代码: 约`150行`&#13;
- 主要内容&#13;
    - 添加动态路由, 使用`字典树`&#13;
    - 支持 `:name`与`*filepath`两种模式&#13;
- 有点忘了字典树是啥了, 写之前还回顾了一下基础课字典树 : )&#13;
&#13;
 **字典树操作** &#13;
 &#13;
- 插入: 对应创建路由时, 把路由插入字典树中&#13;
- 查询: 当请求来临时, 去字典树找到对应的路由&#13;
&#13;
**框架基本结构**&#13;
```go&#13;
// 文件结构&#13;
.&#13;
├── fgee&#13;
│   ├── context.go&#13;
│   ├── fgee.go&#13;
│   ├── go.mod&#13;
│   ├── router.go&#13;
│   ├── router_test.go&#13;
│   └── tire.go&#13;
├── go.mod&#13;
└── main.go&#13;
&#13;
// context.go&#13;
&#13;
// Context 上下文结构&#13;
// 在ServeHTTP方法中被创建&#13;
type Context struct {&#13;
	// 请求与响应&#13;
	Req    *http.Request&#13;
	Writer http.ResponseWriter&#13;
	// 请求信息&#13;
	Path   string&#13;
	Method string&#13;
	// 路由匹配后的参数&#13;
	Params map[string]string&#13;
	// 响应信息&#13;
	StatusCode int&#13;
}&#13;
```&#13;
- 存在问题: 字典树处理不严谨, 路由会冲突, 比如创建路由/:age, 再创建路由/16, 这样就会出现冲突问题&#13;
&#13;
&#13;
**教程链接**&#13;
&#13;
&gt; [7天用Go从零实现Web框架Gee教程](https://geektutu.com/post/gee.html)。</description><guid isPermaLink="true">https://fluent12138.github.io//post/7-tian-yong-Go-cong-ling-shi-xian-Web-kuang-jia-Gee.html</guid><pubDate>Sun, 10 Mar 2024 08:22:06 +0000</pubDate></item><item><title>erlang-OTP进程池</title><link>https://fluent12138.github.io//post/erlang-OTP-jin-cheng-chi.html</link><description># OTP应用 - 进程池&#13;
## 架构图 - 监督树&#13;
&#13;
![ppool架构图.excalidraw.png](https://cdn.acwing.com/media/article/image/2023/04/08/36510_68e5fc62d6-ppool架构图.excalidraw.png) &#13;
&#13;
## 监督者实现&#13;
&#13;
### ppool_supersup流程图解&#13;
![ppool_supersup逻辑.excalidraw.png](https://cdn.acwing.com/media/article/image/2023/04/09/36510_f521f702d6-ppool_supersup逻辑.excalidraw.png) &#13;
&#13;
### code&#13;
&#13;
```erlang&#13;
-module(ppool_supersup).  &#13;
-author('勒勒').  &#13;
-behavior(supervisor).  &#13;
%% API  &#13;
-export([start_link/0, stop/0, start_pool/3, stop_pool/1]).  &#13;
-export([init/1]).  &#13;
   &#13;
start_link() -&gt;  &#13;
  io:format('start supersup ...~n'),  &#13;
  supervisor:start_link({local, ppool}, ?MODULE, []). %{local, Name} 命名  &#13;
  &#13;
stop() -&gt;  &#13;
  case whereis(ppool) of  &#13;
    P when is_pid(P) -&gt;  &#13;
      exit(P, kill);  &#13;
    _ -&gt; ok  &#13;
  end.  &#13;
  &#13;
init([]) -&gt;  &#13;
  MaxRestart = 6,  &#13;
  MaxTime = 3000,  &#13;
  {ok, {{one_for_one, MaxRestart, MaxTime}, []}}.  &#13;
  &#13;
%% Limit : 工作者进程个数; MFA元组 : 工作者进程监督者启动工作者进程需要的{M, F, A}元组  &#13;
start_pool(Name, Limit, MFA) -&gt;  &#13;
  io:format('start pool ... args: {~p, ~p, ~p}~n', [Name, Limit, MFA]),  &#13;
  ChildSpec = {Name,  &#13;
               {ppool_sup, start_link, [Name, Limit, MFA]}, % {M, F, A}  &#13;
               permanent, 10500, supervisor, [ppool_sup]  &#13;
              },  &#13;
  supervisor:start_child(ppool, ChildSpec).  &#13;
  &#13;
stop_pool(Name) -&gt;  &#13;
  supervisor:terminate_child(ppool, Name),  &#13;
  supervisor:delete_child(ppool, Name).&#13;
```&#13;
### ppool_sup流程&#13;
`start_link -&gt; (supervisor) -&gt; init(初始化信息, 需要开启serv)`&#13;
### code&#13;
```erlang&#13;
-module(ppool_sup).  &#13;
-author('勒勒').  &#13;
-behavior(supervisor).  &#13;
%% API  &#13;
-export([start_link/3, init/1]).  &#13;
  &#13;
start_link(Name, Limit, MFA) -&gt;  &#13;
  io:format('start ppool_sup...~n'),  &#13;
  supervisor:start_link(?MODULE, {Name, Limit, MFA}).  &#13;
  &#13;
init({Name, Limit, MFA}) -&gt;  &#13;
  io:format('init ppool_sup...~n'),  &#13;
  MaxRestart = 1,  &#13;
  MaxTime = 3600,  &#13;
  {ok, {{one_for_all, MaxRestart, MaxTime},  &#13;
        [{serv,  &#13;
          {ppool_serv, start_link, [Name, Limit, self(), MFA]}, % {M, F, A}  &#13;
          permanent, 5000, worker, [ppool_serv]  &#13;
        }]  &#13;
       }}.&#13;
```&#13;
### ppool_worker_sup流程&#13;
`start_link -&gt; (supervisor) -&gt; init(初始化信息, 使用simpler_one_for_one)`&#13;
code&#13;
```erlang&#13;
-module(ppool_worker_sup).  &#13;
-author('勒勒').  &#13;
-behavior(supervisor).  &#13;
%% API  &#13;
-export([start_link/1, init/1]).  &#13;
  &#13;
start_link(MFA = {_, _, _}) -&gt;  &#13;
  supervisor:start_link(?MODULE, MFA).  &#13;
  &#13;
init({M, F, A}) -&gt;  &#13;
  io:format('worker sup init...~n'),  &#13;
  &#13;
  io:format('MFA : ~p ~n', [{M, F, A}]),  &#13;
  MaxRestart = 5,  &#13;
  MaxTime = 3600,  &#13;
  {ok, {{simple_one_for_one, MaxRestart, MaxTime},  &#13;
        [{  &#13;
          ppool_worker, {M, F, A},  &#13;
          temporary, 5000, worker, [M]  &#13;
        }]  &#13;
    }}.&#13;
```&#13;
## 进程池服务器&#13;
&#13;
### ppool_serv流程图&#13;
![ppool_serv逻辑.excalidraw.png](https://cdn.acwing.com/media/article/image/2023/04/08/36510_81a1a095d6-ppool_serv逻辑.excalidraw.png) &#13;
### code&#13;
```erlang&#13;
-module(ppool_serv).  &#13;
-author('勒勒').  &#13;
-behavior(gen_server).  &#13;
-define(SPEC(MFA), {worker_sup,  &#13;
                    {ppool_worker_sup, start_link, [MFA]},  &#13;
                    permanent, 10000, supervisor, [ppool_worker_sup]  &#13;
                   }).  &#13;
-record(state, {limit = 0, sup, refs, queue = queue:new()}). % refs为监控器的引用  &#13;
%% API  &#13;
-export([start/4, start_link/4, run/2, sync_queue/2, async_queue/2, stop/1]).  &#13;
-export([init/1, handle_info/2, handle_call/3, handle_cast/2, code_change/3, terminate/2]).  &#13;
  &#13;
start(Name, Limit, Sup, MFA) when is_atom(Name), is_integer(Limit) -&gt;  &#13;
  gen_server:start({local, Name}, ?MODULE, {Limit, MFA, Sup}, []).  &#13;
  &#13;
start_link(Name, Limit, Sup, MFA) when is_atom(Name), is_integer(Limit) -&gt;  &#13;
  io:format('start ppool_serv ~p ... ~n ', [Name]),  &#13;
  gen_server:start_link({local, Name}, ?MODULE, {Limit, MFA, Sup}, []).  &#13;
  &#13;
run(Name, Args) -&gt;  &#13;
  io:format('test start run ~n'),  &#13;
  gen_server:call(Name, {run, Args}).  &#13;
  &#13;
sync_queue(Name, Args) -&gt;  &#13;
  gen_server:call(Name, {sync, Args}, infinity).  &#13;
  &#13;
async_queue(Name, Args) -&gt;  &#13;
  gen_server:cast(Name, {async, Args}).  &#13;
  &#13;
stop(Name) -&gt;  &#13;
  gen_server:call(Name, stop).  &#13;
  &#13;
init({Limit, MFA, Sup}) -&gt;  &#13;
  %% 注释部分会造成死锁!  &#13;
  %% 在ppool_sup中需要启动serv, 等待init信息返回, 而init中使用start_child需要等待ppool_sup返回  &#13;
  %% {ok, Pid} = supervisor:start_child(Sup, ?SPEC(MFA)),  &#13;
  io:format('init ppool_serv...~n'),  &#13;
  self() ! {start_worker_supervisor, Sup, MFA},  &#13;
  {ok, #state{limit = Limit, refs = gb_sets:empty()}}.  &#13;
  &#13;
%% 获取任务结束信息  &#13;
handle_info({'DOWN', Ref, process, _Pid,  _}, S = #state{refs = Refs}) -&gt;  &#13;
  io:format('received down msg, bool : ~p ~n', [gb_sets:is_element(Ref, Refs)]),  &#13;
  case gb_sets:is_element(Ref, Refs) of  &#13;
    true -&gt; handle_down_worker(Ref, S);  &#13;
    false -&gt; {noreply, S}  &#13;
  end;  &#13;
  &#13;
handle_info({start_worker_supervisor, Sup, MFA}, S = #state{}) -&gt;  &#13;
  io:format('start worker...~n'),  &#13;
  {ok, Pid} = supervisor:start_child(Sup, ?SPEC(MFA)),  &#13;
  io:format('start worker pid : ~p ~n', [Pid]),  &#13;
  {noreply, S#state{sup = Pid}};  &#13;
  &#13;
handle_info(Msg, State) -&gt;  &#13;
  io:format('UnKnown msg : ~p ~n', [Msg]),  &#13;
  {noreply, State}.  &#13;
  &#13;
%% 处理结束任务  &#13;
handle_down_worker(Ref, S = #state{limit = L, sup = Sup, refs = Refs}) -&gt;  &#13;
  case queue:out(S#state.queue) of  &#13;
    {{value, {From, Args}}, Q} -&gt; % 处理同步  &#13;
      {ok, Pid} = supervisor:start_child(Sup, Args),  &#13;
      NewRef = erlang:monitor(process, Pid),  &#13;
      NewRefs = gb_sets:insert(NewRef, gb_sets:delete(Ref, Refs)), %为什么是insert 而不是add  &#13;
      gen_server:reply(From, {ok, Pid}),  &#13;
      {noreply, S#state{refs = NewRefs, queue = Q}};  &#13;
    {{value, Args}, Q} -&gt; % 处理异步  &#13;
      {ok, Pid} = supervisor:start_child(Sup, Args),  &#13;
      NewRef = erlang:monitor(process, Pid),  &#13;
      NewRefs = gb_sets:insert(NewRef, gb_sets:delete(Ref, Refs)),  &#13;
      {noreply, S#state{refs = NewRefs, queue = Q}};  &#13;
    {empty, _} -&gt;  &#13;
      {noreply, S#state{limit = L + 1, refs = gb_sets:delete(Ref, Refs)}}  &#13;
  end.  &#13;
  &#13;
%% run  &#13;
handle_call({run, Args}, _From, S = #state{limit = N, sup = Sup, refs = R}) when N &gt; 0 -&gt;  &#13;
  io:format('args : ~p, limit : ~p, sup : ~p, refs : ~p ~n', [Args, N, Sup, R]),  &#13;
  {ok, Pid} = supervisor:start_child(Sup, Args),  &#13;
  Ref = erlang:monitor(process, Pid),  &#13;
  {reply, {ok, Pid}, S#state{limit = N - 1, refs = gb_sets:add(Ref, R)}};  &#13;
  &#13;
handle_call({run, _Args}, _From, S = #state{limit = N}) when N =&lt; 0 -&gt;  &#13;
  {reply, noalloc, S};  &#13;
  &#13;
%% sync_queue  &#13;
handle_call({sync, Args}, _From, S = #state{limit = N, sup = Sup, refs = R}) when N &gt; 0 -&gt;  &#13;
  {ok, Pid} = supervisor:start_child(Sup, Args),  &#13;
  Ref = erlang:monitor(process, Pid),  &#13;
  {reply, {ok, Pid}, S#state{limit = N - 1, refs = gb_sets:add(Ref, R)}};  &#13;
  &#13;
handle_call({sync, Args}, From, S = #state{queue = Q}) -&gt;  &#13;
  {noreply, S#state{queue = queue:in({From, Args}, Q)}};  &#13;
  &#13;
%% stop &amp; 未知消息  &#13;
handle_call(stop, _From, State) -&gt; {stop, normal, ok, State};  &#13;
  &#13;
handle_call(_Msg, _From, State) -&gt; {noreply, State}.  &#13;
  &#13;
%% async_queue  &#13;
handle_cast({async, Args}, S = #state{limit = N, sup = Sup, refs =  R}) when N &gt; 0 -&gt;  &#13;
  {ok, Pid} = supervisor:start_child(Sup, Args),  &#13;
  Ref = erlang:monitor(process, Pid),  &#13;
  {noreply, S#state{limit = N - 1, refs = gb_sets:add(Ref, R)}};  &#13;
  &#13;
handle_cast({async, Args}, S = #state{limit = N, queue = Q}) when N =&lt; 0 -&gt;  &#13;
  {noreply, S#state{queue = queue:in(Args, Q)}};  &#13;
  &#13;
handle_cast(_Msg, State) -&gt; {noreply, State}.  &#13;
  &#13;
code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.  &#13;
  &#13;
terminate(_Reason, _State) -&gt; ok.&#13;
```&#13;
&#13;
## 工作者&#13;
### 逻辑&#13;
`主要是通过超时事件定时发送消息`&#13;
### code&#13;
```erlang&#13;
-module(ppool_nagger).  &#13;
-author('勒勒').  &#13;
-behavior(gen_server).  &#13;
  &#13;
%% API  &#13;
-export([start_link/4, stop/1]).  &#13;
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, code_change/3, terminate/2]).  &#13;
  &#13;
start_link(Task, Delay, Max, SendTo) -&gt;  &#13;
  gen_server:start_link(?MODULE, {Task, Delay, Max, SendTo}, []).  &#13;
  &#13;
stop(Pid) -&gt; gen_server:call(Pid, stop).  &#13;
  &#13;
init({Task, Delay, Max, SendTo}) -&gt;  &#13;
  {ok, {Task, Delay, Max, SendTo}, Delay}.  &#13;
  &#13;
%%% otp回调函数  &#13;
handle_call(stop, normal, State) -&gt;  &#13;
  {stop, normal, ok, State};  &#13;
  &#13;
handle_call(_Msg, _From, State) -&gt; {noreply, State}.  &#13;
  &#13;
handle_cast(_Msg, State) -&gt; {noreply, State}.  &#13;
  &#13;
%% 通过超时的方式发送消息  &#13;
handle_info(timeout, {Task, Delay, Max, SendTo}) -&gt;  &#13;
  SendTo ! {self(), Task},  &#13;
  io:format('send task : ~p ~n', [Task]),  &#13;
  if Max =:= infinity -&gt;  &#13;
       {noreply, {Task, Delay, Max, SendTo}, Delay};  &#13;
     Max =&lt; 1 -&gt;  &#13;
       {stop, normal, {Task, Delay, 0, SendTo}};  &#13;
     Max &gt; 1 -&gt;  &#13;
       {noreply, {Task, Delay, Max - 1, SendTo}, Delay}  &#13;
  end.  &#13;
  &#13;
code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.  &#13;
  &#13;
terminate(_Reason, _State) -&gt; ok.&#13;
```&#13;
&#13;
## [修改为OTP应用](https://git.acwing.com/fluentx/ppool/-/tree/main/) &#13;
&#13;
&#13;
## 运行进程池&#13;
&#13;
```erlang&#13;
erl -make &#13;
&#13;
erl -pa ebin/&#13;
&#13;
make:all([load]).&#13;
&#13;
application:start(ppool).&#13;
&#13;
ppool:start_pool(nagger, 2, {ppool_nagger, start_link, []}).&#13;
&#13;
%% 同步不入队&#13;
ppool:run(nagger, ['finish the chapter!', 1000, 5, self()]).&#13;
ppool:run(nagger, ['Watch a good movie!', 1000, 5, self()]).&#13;
ppool:run(nagger, ['Playing game!', 1000, 5, self()]).&#13;
flush().&#13;
&#13;
%% 同步入队&#13;
ppool:sync_queue(nagger, ['finish the chapter!', 1000, 5, self()]).  &#13;
ppool:sync_queue(nagger, ['Watch a good movie!', 1000, 5, self()]).&#13;
ppool:sync_queue(nagger, ['Playing game!', 1000, 5, self()]).&#13;
&#13;
%% 异步入队&#13;
ppool:async_queue(nagger, ['finish the chapter!', 1000, 5, self()]).  &#13;
ppool:async_queue(nagger, ['Watch a good movie!', 1000, 5, self()]).&#13;
ppool:async_queue(nagger, ['Playing game!', 1000, 5, self()]).&#13;
&#13;
%% 查看当前运行的应用&#13;
application:which_applications().&#13;
&#13;
application:stop(ppool).&#13;
```&#13;
&#13;
&lt;!-- ##{'timestamp':1680962400}## --&gt;。</description><guid isPermaLink="true">https://fluent12138.github.io//post/erlang-OTP-jin-cheng-chi.html</guid><pubDate>Sat, 08 Apr 2023 14:00:00 +0000</pubDate></item><item><title>erlang-gen_event事件处理器</title><link>https://fluent12138.github.io//post/erlang-gen_event-shi-jian-chu-li-qi.html</link><description># 事件处理器&#13;
&#13;
## 图解&#13;
![event-事件处理器.excalidraw.png](https://cdn.acwing.com/media/article/image/2023/04/05/36510_f828b03cd3-event-事件处理器.excalidraw.png) &#13;
&#13;
## version 2.0&#13;
```&#13;
-module(curling).&#13;
-author('勒勒').&#13;
%% API&#13;
-export([start_link/2, add_points/3, next_round/1, join_feed/2, leave_feed/2, game_info/1]).&#13;
&#13;
start_link(TeamA, TeamB) -&gt;&#13;
  {ok, Pid} = gen_event:start_link(),&#13;
  %% 记分板&#13;
  gen_event:add_handler(Pid, curling_scoreboard, []),&#13;
  %% 启动比赛状态累加器&#13;
  gen_event:add_handler(Pid, curling_accumulator, []),&#13;
  set_teams(Pid, TeamA, TeamB),&#13;
  {ok, Pid}.&#13;
&#13;
set_teams(Pid, TeamA, TeamB) -&gt;&#13;
  gen_event:notify(Pid, {set_teams, TeamA, TeamB}).&#13;
&#13;
add_points(Pid, Team, N) -&gt;&#13;
  gen_event:notify(Pid, {add_points, Team, N}).&#13;
&#13;
next_round(Pid) -&gt; gen_event:notify(Pid, next_round).&#13;
&#13;
%% 为进程ToPid订阅比赛消息&#13;
join_feed(Pid, ToPid) -&gt;&#13;
  HandlerId = {curling_feed, make_ref()},&#13;
  gen_event:add_handler(Pid, HandlerId, [ToPid]),&#13;
  HandlerId.&#13;
&#13;
leave_feed(Pid, HandlerId) -&gt;&#13;
  gen_event:delete_handler(Pid, HandlerId, leave_feed).&#13;
&#13;
%% 返回当前比赛状态, 为迟到订阅的提供&#13;
game_info(Pid) -&gt;&#13;
  gen_event:call(Pid, curling_accumulator, game_data).&#13;
```&#13;
&#13;
## callback&#13;
- 通用callback&#13;
```&#13;
-module(gen_event_callback).&#13;
-author('勒勒').&#13;
-behavior(gen_event).&#13;
%% API&#13;
-export([init/1, handle_event/2, handle_call/2, handle_info/2, code_change/3, terminate/2]).&#13;
&#13;
init([]) -&gt; [].&#13;
&#13;
handle_event(_, State) -&gt; {ok, State}.&#13;
&#13;
handle_call(_, State) -&gt; {ok, ok, State}.&#13;
&#13;
handle_info(_, State) -&gt; {ok, State}.&#13;
&#13;
code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.&#13;
&#13;
terminate(_Reason, _State) -&gt; ok.&#13;
```&#13;
&#13;
- curling_scoreboard&#13;
```&#13;
-module(curling_scoreboard).&#13;
-author('勒勒').&#13;
-import(curling_scoreboard_hw, [set_teams/2, add_point/1, reset_board/1, next_round/0]).&#13;
%% API&#13;
-export([init/1, handle_event/2, handle_call/2, handle_info/2]).&#13;
&#13;
init([]) -&gt; {ok, []}.&#13;
&#13;
handle_event({set_teams, TeamA, TeamB}, State) -&gt;&#13;
  io:format('set teams'),&#13;
  curling_scoreboard_hw:set_teams(TeamA, TeamB),&#13;
  {ok, State};&#13;
&#13;
handle_event({add_points, Team, N}, State) -&gt;&#13;
  [curling_scoreboard_hw:add_point(Team) || _ &lt;- lists:seq(1, N)],&#13;
  {ok, State};&#13;
&#13;
handle_event(next_round, State) -&gt;&#13;
  curling_scoreboard_hw:next_round(),&#13;
  {ok, State};&#13;
&#13;
handle_event(_, State) -&gt; {ok, State}.&#13;
&#13;
handle_call(_, State) -&gt; {ok, ok, State}.&#13;
&#13;
handle_info(_, State) -&gt; {ok, State}.&#13;
&#13;
```&#13;
- curling_feed&#13;
```&#13;
-module(curling_feed).&#13;
-author('勒勒').&#13;
-behavior(gen_event).&#13;
%% API&#13;
-export([init/1, handle_event/2, handle_call/2, handle_info/2, code_change/3, terminate/2]).&#13;
&#13;
init([Pid]) -&gt; {ok, Pid}.&#13;
&#13;
handle_event(Event, Pid) -&gt;&#13;
  Pid ! {curling_feed, Event},&#13;
  {ok, Pid}.&#13;
&#13;
handle_call(_, State) -&gt; {ok, ok, State}.&#13;
&#13;
handle_info(_, State) -&gt; {ok, State}.&#13;
&#13;
code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.&#13;
&#13;
terminate(_Reason, _State) -&gt; ok.&#13;
&#13;
```&#13;
- curling_accumulator&#13;
&#13;
```&#13;
-module(curling_accumulator).&#13;
-author('勒勒').&#13;
-behavior(gen_event).&#13;
%% API&#13;
-export([init/1, handle_event/2, handle_call/2, handle_info/2, code_change/3, terminate/2]).&#13;
-record(state, {teams = orddict:new(), round = 0}).&#13;
&#13;
init([]) -&gt; {ok, #state{}}.&#13;
&#13;
handle_event({set_teams, TeamA, TeamB}, S = #state{teams = T}) -&gt;&#13;
  Teams = orddict:store(TeamA, 0, orddict:store(TeamB, 0, T)),&#13;
  {ok, S#state{teams =  Teams}};&#13;
&#13;
handle_event({add_points, Team, N}, S = #state{teams = T}) -&gt;&#13;
  Teams = orddict:update_counter(Team, N, T), %% 如果存在则 Val += incr, 不存在添加一个Key Val(为空直接添加, 否则依次寻找)&#13;
  {ok, S#state{teams = Teams}};&#13;
&#13;
handle_event(next_round, S = #state{}) -&gt;&#13;
  {ok, S#state{round = S#state.round + 1}};&#13;
&#13;
handle_event(_Event, State = #state{}) -&gt; {ok, State}.&#13;
&#13;
handle_call(game_data, S = #state{teams = T, round = R}) -&gt;&#13;
  {ok, {orddict:to_list(T), {round, R}}, S};&#13;
&#13;
handle_call(_, State) -&gt; {ok, ok, State}.&#13;
&#13;
handle_info(_, State) -&gt; {ok, State}.&#13;
&#13;
code_change(_OldVsn, State, _Extra) -&gt; {ok, State}.&#13;
&#13;
terminate(_Reason, _State) -&gt; ok.&#13;
```&#13;
&#13;
## mock curling_scoreboard_hw&#13;
```&#13;
-module(curling_scoreboard_hw).&#13;
-author('勒勒').&#13;
&#13;
%% API&#13;
-export([set_teams/2, next_round/0, add_point/1, reset_board/0]).&#13;
&#13;
%% 在计分板上显示参赛队伍&#13;
set_teams(TeamA, TeamB) -&gt;&#13;
  io:format('Scoreboard: Team ~s vs Team ~s ~n', [TeamA, TeamB]).&#13;
&#13;
next_round() -&gt;&#13;
  io:format('Scoreboard: round over ~n').&#13;
&#13;
add_point(Team) -&gt;&#13;
  io:format('Scoreboard:increased score of team ~s by 1~n', [Team]).&#13;
&#13;
reset_board() -&gt;&#13;
  io:format('Scoreboard: All teams are undefined and al1 scores are 0~n').&#13;
&#13;
```&#13;
&#13;
&lt;!-- ##{'timestamp':1680703200}## --&gt;。</description><guid isPermaLink="true">https://fluent12138.github.io//post/erlang-gen_event-shi-jian-chu-li-qi.html</guid><pubDate>Wed, 05 Apr 2023 14:00:00 +0000</pubDate></item><item><title>erlang-gen_fsm 游戏交易</title><link>https://fluent12138.github.io//post/erlang-gen_fsm%20-you-xi-jiao-yi.html</link><description>![fsm-游戏交易.excalidraw.png](https://cdn.acwing.com/media/article/image/2023/04/04/36510_86007705d2-fsm-游戏交易.excalidraw.png)&#13;
&#13;
 **code** &#13;
 &#13;
```&#13;
%%%-------------------------------------------------------------------&#13;
%%% @author 勒勒&#13;
%%% @copyright (C) 2023, &lt;COMPANY&gt;&#13;
%%% @doc&#13;
%%%&#13;
%%% @end&#13;
%%% Created : 31. 3月 2023 14:38&#13;
%%%-------------------------------------------------------------------&#13;
-module(trade_fsm).&#13;
-author('勒勒').&#13;
-behavior(gen_fsm).&#13;
-record(state, {name = '', other, ownitems = [], otheritems = [], monitor, from}). % from就是gen_fsm中发送消息处&#13;
%% 公共API&#13;
-export([start/1, start_link/1, trade/2, accept_trade/1, make_offer/2, retract_offer/2, ready/1, cancel/1]).&#13;
%% gen_sfm回调函数&#13;
-export([init/1, handle_event/3, handle_sync_event/4, handle_info/3, terminate/3, code_change/4,&#13;
        % 定制的状态名&#13;
        idle/2, idle/3, idle_wait/2, idle_wait/3, negotiate/2, negotiate/3, wait/2, ready/2, ready/3&#13;
        ]).&#13;
&#13;
%%% 公共API&#13;
start(Name) -&gt; gen_fsm:start(?MODULE, [Name], []).&#13;
&#13;
start_link(Name) -&gt; gen_fsm:start_link(?MODULE, [Name], []).&#13;
&#13;
%% 请求开始交易谈话. 当/如果对方接收时返回&#13;
trade(OwnPid, OtherPid) -&gt;&#13;
  gen_fsm:sync_send_event(OwnPid, {negotiate, OtherPid}, 30000).&#13;
&#13;
%% 接收某个玩家的交易请求&#13;
accept_trade(OwnPid) -&gt;&#13;
  gen_fsm:sync_send_event(OwnPid, accept_negotiate).&#13;
&#13;
%% 从物品列表中选择一个进行交易&#13;
make_offer(OwnPid, Item) -&gt;&#13;
  gen_fsm:send_event(OwnPid, {make_offer, Item}).&#13;
&#13;
%% 撤销某个交易物品&#13;
retract_offer(OwnPid, Item) -&gt;&#13;
  gen_fsm:send_event(OwnPid, {retract_offer, Item}).&#13;
&#13;
%% 宣布自己就绪. 当对方也宣布自己就绪了, 交易就完成了.&#13;
ready(OwnPid) -&gt;&#13;
  gen_fsm:sync_send_event(OwnPid, ready, infinity).&#13;
&#13;
%% 取消交易&#13;
cancel(OwnPid) -&gt;&#13;
  gen_fsm:sync_send_all_state_event(OwnPid, cancel).&#13;
&#13;
%%% FSM 到 FSM&#13;
&#13;
%% 向另一个FSM发送交易会话请求&#13;
ask_negotiate(OwnPid, OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {ask_negotiate, OwnPid}).&#13;
&#13;
%% 转发玩家交易接收请求&#13;
accept_negotiate(OtherPid, OwnPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {accept_negotiate, OwnPid}).&#13;
&#13;
%% 转发玩家的交易物品提供信息&#13;
do_offer(OtherPid, Item) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {do_offer, Item}).&#13;
&#13;
%% 转发玩家交易物品撤销请求&#13;
undo_offer(OtherPid, Item) -&gt;&#13;
  gen_fsm:send_event(OtherPid, {undo_offer, Item}).&#13;
&#13;
%% 询问对方是否就绪&#13;
are_you_ready(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, are_you_ready).&#13;
&#13;
%% 回复未就绪 -&gt; 不在wait状态哦&#13;
not_yet(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, not_yet).&#13;
&#13;
%% 通知对方玩家当前处于等待进入ready状态&#13;
%% 状态会迁移到ready ?&#13;
am_ready(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, 'ready!').&#13;
&#13;
%% 确认fsm处于ready状态&#13;
ack_trans(OtherPid) -&gt;&#13;
  gen_fsm:send_event(OtherPid, ack).&#13;
&#13;
%% 询问是否可以提交&#13;
ask_commit(OtherPid) -&gt;&#13;
  gen_fsm:sync_send_event(OtherPid, ask_commit).&#13;
&#13;
%% 开始同步提交&#13;
do_commit(OtherPid) -&gt;&#13;
  gen_fsm:sync_send_event(OtherPid, do_commit).&#13;
&#13;
%% 礼貌取消&#13;
notify_cancel(OtherPid) -&gt;&#13;
  gen_fsm:send_all_state_event(OtherPid, cancel).&#13;
&#13;
init(Name) -&gt;&#13;
  {ok, idle, #state{name = Name}}.&#13;
&#13;
%% 给玩家发送一条通知, 可以是一条发给玩家进程的消息&#13;
%% 打印在控制台就ok了&#13;
notice(#state{name = N}, Str, Args) -&gt;&#13;
  io:format('~s : '++ Str ++ '~n', [N | Args]).&#13;
&#13;
%% 记录非期望的消息&#13;
unexpected(Msg, State) -&gt;&#13;
  io:format('~p receive unknown event ~p while in state ~p', [self(), Msg, State]).&#13;
&#13;
%%% idle 请求/接收 交易&#13;
%% 异步版本, 关心其他玩家的交易请求&#13;
idle({ask_negotiate, OtherPid}, S = #state{}) -&gt;&#13;
  Ref = monitor(process, OtherPid),&#13;
  notice(S, '~p asked for a trade negotiation', [OtherPid]),&#13;
  {next_state, idle_wait, S#state{other = OtherPid, monitor = Ref}};&#13;
&#13;
idle(Event, Data) -&gt;&#13;
  unexpected(Event, idle),&#13;
  {next_state, idle, Data}.&#13;
&#13;
%% 同步版本, 本方玩家请求另一个玩家进行交易&#13;
idle({negotiate, OtherPid}, From, S=#state{}) -&gt;&#13;
  ask_negotiate(OtherPid, self()),&#13;
  notice(S, 'asking user ~p for a trade', [OtherPid]),&#13;
  Ref = monitor(process, OtherPid),&#13;
  {next_state, idle_wait, S = #state{other = OtherPid, monitor = Ref, from = From}};&#13;
&#13;
idle(Event, _From, Data) -&gt;&#13;
  unexpected(Event, idle),&#13;
  {next_state, idle, Data}.&#13;
&#13;
%%% idle_wait&#13;
%% 接收方, 1.同意协商 2.在我们发送交易请求时, 他也发起了交易&#13;
idle_wait({ask_negotiate, OtherPid}, S = #state{other = OtherPid}) -&gt;&#13;
  gen_fsm:reply(S#state.from, ok), % 通知玩家一切正常&#13;
  notice(S, 'starting negotiation', []),&#13;
  {next_state, negotiate, S};&#13;
&#13;
%% 对方接受了我们的请求, 迁移negotiate状态&#13;
idle_wait({accept_negotiate, OtherPid}, S = #state{other = OtherPid}) -&gt;&#13;
  gen_fsm:reply(S#state.from, ok), % 通知玩家一切正常&#13;
  notice(S, 'starting negotiation', []),&#13;
  {next_state, negotiate, S};&#13;
&#13;
idle_wait(Event, Data) -&gt;&#13;
  unexpected(Event, idle_wait),&#13;
  {next_state, idle_wait, Data}.&#13;
&#13;
%% 发送方, 接收对方玩家请求&#13;
idle_wait(accept_negotiate, _From, S = #state{other = OtherPid}) -&gt;&#13;
  accept_negotiate(OtherPid, self()),&#13;
  notice(S, 'accepting negotiation', []),&#13;
  {reply, ok, negotiate, S};&#13;
&#13;
idle_wait(Event, _From, Data) -&gt;&#13;
  unexpected(Event, idle_wait),&#13;
  {next_state, idle_wait, Data}.&#13;
&#13;
%% 向物品列表中添加一个物品&#13;
add(Item, Items) -&gt;&#13;
  [Item|Items].&#13;
&#13;
%% 从物品列表中删除一个物品&#13;
remove(Item, Items) -&gt;&#13;
  Items -- [Item].&#13;
&#13;
%%% negotiate&#13;
%% 本方提供物品&#13;
negotiate({make_offer, Item}, S = #state{ownitems = OwnItems}) -&gt;&#13;
  do_offer(S#state.other, Item),&#13;
  notice(S, 'offering ~p', [Item]),&#13;
  {next_state, negotiate, S#state{ownitems = add(Item, OwnItems)}};&#13;
&#13;
%% 本方撤销物品&#13;
negotiate({retract_offer, Item}, S = #state{ownitems = OwnItems}) -&gt;&#13;
  undo_offer(S#state.other, Item),&#13;
  notice(S, 'cancelling offer on ~p', [Item]),&#13;
  {next_state, negotiate, S#state{ownitems = remove(Item, OwnItems)}};&#13;
&#13;
%% 对方提供物品&#13;
negotiate({do_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  notice(S, 'other player offering ~p', [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = add(Item, OtherItems)}};&#13;
&#13;
%% 对方撤销物品&#13;
negotiate({undo_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  notice(S, 'other player cancelling offer on ~p', [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = OtherItems}};&#13;
&#13;
%% 当在negotiate状态时, 接收到对方的ready信号, 直接拒绝.&#13;
negotiate(are_you_ready, S = #state{other = OtherPid}) -&gt;&#13;
  io:format('Other user ready to trade ~n'),&#13;
  notice(S, 'Other user ready to transfer goods : ~n You get ~p, The Other side gets ~p', [S#state.otheritems, S#state.ownitems]),&#13;
  not_yet(OtherPid),&#13;
  {next_state, negotiate, S};&#13;
&#13;
negotiate(Event, Data) -&gt;&#13;
  unexpected(Event, negotiate),&#13;
  {next_state, negotiate, Data}.&#13;
&#13;
%% 玩家做完决策 -&gt; 发送ready&#13;
negotiate(ready, From, S = #state{other = OtherPid}) -&gt;&#13;
  are_you_ready(OtherPid),&#13;
  notice(S, 'asking if ready, waiting', []),&#13;
  {next_state, wait, S = #state{from = From}};&#13;
&#13;
negotiate(Event, _From, S) -&gt;&#13;
  unexpected(Event, negotiate),&#13;
  {next_state, negotiate, S}.&#13;
&#13;
%%% wait&#13;
&#13;
%% 当对方撤销/提供物品了, 回退到negotiate状态&#13;
wait({do_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  gen_fsm:reply(S#state.from, offer_changed), % 通知negotiate状态&#13;
  notice(S, 'other side offering ~p', [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = add(Item, OtherItems)}};&#13;
&#13;
wait({undo_offer, Item}, S = #state{otheritems = OtherItems}) -&gt;&#13;
  gen_fsm:reply(S#state.from, offer_changed), % 通知negotiate状态&#13;
  notice(S, 'other side cancelling offer of ~p', [Item]),&#13;
  {next_state, negotiate, S#state{otheritems = remove(Item, OtherItems)}};&#13;
&#13;
%% 对方询问本方是否ready&#13;
wait(are_you_ready, S = #state{}) -&gt;&#13;
  am_ready(S#state.other),&#13;
  notice(S, 'asked if ready, and I am. Waiting for same reply', []),&#13;
  {next_state, wait, S};&#13;
&#13;
%% 对方不同意&#13;
wait(not_yet, S = #state{}) -&gt;&#13;
  notice(S, 'Other not ready yet', []),&#13;
  {next_state, wait, S};&#13;
&#13;
%% 收到ready!&#13;
wait('ready!', S = #state{}) -&gt;&#13;
  am_ready(S#state.other),&#13;
  ack_trans(S#state.other),&#13;
  gen_fsm:reply(#state.from, ok),&#13;
  notice(S, 'other side is ready. Moving to ready state', []),&#13;
  {next_state, ready, S};&#13;
&#13;
%% 不期待的消息&#13;
wait(Event, Data) -&gt;&#13;
  unexpected(Event, wait),&#13;
  {next_state, wait, Data}.&#13;
&#13;
%%% ready, 选择一个FSM去完成ready, erlang中进程是排好序的, 可以比较大小&#13;
priority(OwnPid, OtherPid) when OwnPid &gt; OtherPid -&gt; true;&#13;
priority(OwnPid, OtherPid) when OtherPid &gt; OwnPid -&gt; false.&#13;
&#13;
ready(ack, S = #state{}) -&gt;&#13;
  case priority(self(), S#state.other) of&#13;
      true -&gt;&#13;
        try&#13;
          notice(S, 'asking for commit', []),&#13;
          ready_commit = ask_commit(S#state.other),&#13;
          notice(S, 'ordering commit', []),&#13;
          ok = do_commit(S#state.other),&#13;
          commit(S),&#13;
          {stop, normal, S}&#13;
        catch Class:Reason -&gt;&#13;
          %% 退出!, ready_commit或do_commit失败了&#13;
          notice(S, 'commit failed', []),&#13;
          {stop, {Class, Reason}, S}&#13;
        end;&#13;
      false -&gt;&#13;
        {next_state, ready, S}&#13;
  end;&#13;
&#13;
ready(Event, Data) -&gt;&#13;
  unexpected(Event, ready),&#13;
  {next_state, ready, Data}.&#13;
&#13;
ready(ask_commit, _From, S) -&gt;&#13;
  notice(S, 'replying to ask_commit', []),&#13;
  {reply, ready_commit, ready, S};&#13;
&#13;
ready(do_commit, _From, S) -&gt;&#13;
  notice(S, 'commiting...', []),&#13;
  commit(S),&#13;
  {stop, normal, ok, S};&#13;
&#13;
ready(Event, _From, S) -&gt;&#13;
  unexpected(Event, ready),&#13;
  {next_state, ready, S}.&#13;
&#13;
commit(S = #state{}) -&gt;&#13;
  io:format('Transaction completed for ~s.', [S#state.name]),&#13;
  io:format('Items send are: ~n ~p ~n received are: ~n ~p ~n', [S#state.ownitems, S#state.otheritems]),&#13;
  io:format('The operation should have some atomic save in a database').&#13;
&#13;
%% 对方玩家取消交易&#13;
%% 停止正再做的工作 终止进程&#13;
handle_event(cancel, _StateName, S = #state{}) -&gt;&#13;
  notice(S, 'received cancel event', []),&#13;
  {stop, other_cancelled, S};&#13;
&#13;
handle_event(Event, StateName, Data) -&gt;&#13;
  unexpected(Event, StateName),&#13;
  {next_state, StateName, Data}.&#13;
&#13;
%% 本方玩家终止交易, 必须通知对方玩家我们退出了&#13;
handle_sync_event(cancel, _From, _StateName, S = #state{}) -&gt;&#13;
  notify_cancel(S#state.other),&#13;
  notice(S, 'cancelling trade, sending cancel event', []),&#13;
  {stop, cancelled, ok, S};&#13;
&#13;
handle_sync_event(Event, _From, StateName, Data) -&gt;&#13;
  unexpected(Event, StateName),&#13;
  {next_state, StateName, Data}.&#13;
&#13;
%% 处理对方FSM崩溃事件&#13;
handle_info({'DOWN', Ref, process, Pid, Reason}, _, S = #state{other = Pid, monitor=Ref}) -&gt;&#13;
  notice(S, 'Other side dead', []),&#13;
  {stop, {other_down, Reason}, S};&#13;
&#13;
handle_info(Info, StateName, Data) -&gt;&#13;
  unexpected(Info, StateName),&#13;
  {next_state, StateName, Data}.&#13;
&#13;
code_change(_OldVsn, StateName, Data, _Extra) -&gt;&#13;
  {ok, StateName, Data}.&#13;
&#13;
terminate(_Reason, _StateName, _StateData) -&gt; ok.&#13;
```&#13;
&lt;!-- ##{'timestamp':1680616800}## --&gt;。</description><guid isPermaLink="true">https://fluent12138.github.io//post/erlang-gen_fsm%20-you-xi-jiao-yi.html</guid><pubDate>Tue, 04 Apr 2023 14:00:00 +0000</pubDate></item><item><title>erlang-并发应用设计之提醒器</title><link>https://fluent12138.github.io//post/erlang--bing-fa-ying-yong-she-ji-zhi-ti-xing-qi.html</link><description># [Erlang并发应用设计之提醒器](https://git.acwing.com/fluentx/erlang-reminder/-/tree/main/) &#13;
&#13;
&#13;
&#13;
&gt; 主要文件为: evserv.erl(事件服务器)、event.erl(事件进程)、test.erl(测试，模拟客户端)、sup.erl(重启器)&#13;
&#13;
## 理解问题&#13;
为了编写这个小应用， 需要做的事情&#13;
&#13;
- 添加一个事件， 包括事件名，事件描述信息，最后期限&#13;
- 当事件到达约定期限， 发出警告&#13;
- 根据事件名字取消事件&#13;
- 通过命令行或系统进行交互&#13;
&#13;
&#13;
&#13;
&gt; 此应用没有做信息持久化， 通过Erlang数据结构在运行时存储信息&#13;
&#13;
 &#13;
  **程序结构如下** &#13;
![reminder-client-server.png](https://cdn.acwing.com/media/article/image/2023/03/26/36510_7e46851ecb-reminder-client-server.png) &#13;
&#13;
### server(以下统称事件服务器)需要做的任务&#13;
- 接收客户端的订阅&#13;
- 把来自事件服务器的消息转发给每个订阅者&#13;
- 接收增加事件的消息(需要时会启动x, y, z进程)&#13;
- 接收取消事件消息, 随后杀死事件进程&#13;
&#13;
### 客户进程任务&#13;
- 向事件服务器发起订阅, 并接受通知信息&#13;
- 请求服务器增加一个具体的事件&#13;
- 请求服务器取消一个事件&#13;
- 监控服务器&#13;
- 在需要时, 关闭事件服务器&#13;
&#13;
### 进程x,y,z需要做的任务&#13;
- 当计时器到时, 给事件服务器进程发送一条信息&#13;
- 接收事件取消消息, 然后死亡&#13;
&#13;
![骨架.png](https://cdn.acwing.com/media/article/image/2023/03/26/36510_89eed0aacb-骨架.png)&#13;
&#13;
&#13;
&gt; 在真实的应用中，把每个待提醒的事件都表示为一个进程的做法可能有些过度了，并且难以&#13;
扩展到大量事件的场合。</description><guid isPermaLink="true">https://fluent12138.github.io//post/erlang--bing-fa-ying-yong-she-ji-zhi-ti-xing-qi.html</guid><pubDate>Sun, 26 Mar 2023 14:00:00 +0000</pubDate></item><item><title>关于</title><link>https://fluent12138.github.io//about.html</link><description>## 一个正在努力生活的人&#13;
&#13;
- 正在用的吃饭的家伙&#13;
    - Erlang&#13;
- 以后可能会让我吃上饭的家伙&#13;
    - Go、Java&#13;
    &#13;
**希望大家都能好好吃饭！**。</description><guid isPermaLink="true">https://fluent12138.github.io//about.html</guid><pubDate>Sun, 10 Mar 2024 08:18:58 +0000</pubDate></item></channel></rss>